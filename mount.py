'''
Условия задачи:
В одном из горнолыжных курортов Италии проводятся соревнования по горнолыжному спуску.
Каждому спортсмену предстоит скатиться с горы на лыжах. На любом этапе спуска участник получает определенное число очков.
После прохождения трассы очки суммируются. Участник, набирающий наибольшее количество очков, выигрывает.
Гора представляет собой треугольник, в качестве элементов которого выступают целые числа - очки за прохождение этапа.
На каждом уровне спортсмену предоставляется выбор - двигаться вниз влево или вниз вправо.
Начало спуска - в самой высокой точке горы, конец в одной из самых низких.
                               1
                              4 3
                             5 6 7
                            8 9 0 9
Требуется найти максимальное количество очков, которое может набрать спортсмен.

Формат входных данных:
На вход подаётся целое число n, число этапов (1 <= n >= 100),
далее n строк, каждая из которых характеризует свой уровень. В строке с номером
i содержится ровно i целых чисел: a1, a2, . . . , ai (-100 <= ak <= 100, 1 <= k <= i)
количество очков в каждой из позиций.
Формат выходных данных:
Целое искомое число
Пример:
Вход    |  Выход
4       | 20
1       |
4 3     |
5 6 7   |
8 9 0 9 |
'''



# Считываем и создаём вложенный  не равномерный список
n = int(input())
mount = []
for _ in range(n):
    mount.append(list(map(int, input().split())))

# Создаём дублирующий список заполненный нулями
descent = []
for i in range(n):
    r = []
    for _ in range(i + 1):
        r.append(0)
    descent.append(r)

# Задаём значение вершины в дублирующем списке
descent[0][0] = mount[0][0]

# Высчитываем наиболее выгодный путь
for i in range(1, n):
    for j in range(i + 1):
        if j == 0:
            descent[i][j] = mount[i][0] + descent[i - 1][0]
        elif j == i:
            descent[i][j] = mount[i][j] + descent[i - 1][j - 1]
        else:
            descent[i][j] = mount[i][j] + descent[i - 1][j - 1]
            temp = mount[i][j] + descent[i - 1][j]
            if descent[i][j] < temp:
                descent[i][j] = temp

print(max(descent[-1]))
